//Dinning philosopher using Semaphore ----------------------------------------------------------------------------------------------------------------------------------------------------


#include <pthread.h>
#include <semaphore.h>
#include <stdio.h>

#define N 5
#define THINKING 2
#define HUNGRY 1
#define EATING 0
#define LEFT (phnum + 4) % N
#define RIGHT (phnum + 1) % N

int state[N];
int phil[N] = { 0, 1, 2, 3, 4 };

sem_t mutex;
sem_t S[N];
int cnt = 0;

void test(int phnum)
{
    if (state[phnum] == HUNGRY
        && state[LEFT] != EATING
        && state[RIGHT] != EATING) {
        // state that eating
        state[phnum] = EATING;

        sleep(2);

        printf("Philosopher %d takes fork %d and %d\n",
                      phnum + 1, LEFT + 1, phnum + 1);

        printf("Philosopher %d is Eating\n", phnum + 1);
        cnt++;

        // sem_post(&S[phnum]) has no effect
        // during takefork
        // used to wake up hungry philosophers
        // during putfork
        sem_post(&S[phnum]);
    }
    if(cnt >= 4)
        exit(0);
}

// take up chopsticks
void take_fork(int phnum)
{

    sem_wait(&mutex);

    // state that hungry
    state[phnum] = HUNGRY;

    printf("Philosopher %d is Hungry\n", phnum + 1);

    // eat if neighbours are not eating
    test(phnum);

    sem_post(&mutex);

    // if unable to eat wait to be signalled
    sem_wait(&S[phnum]);

    sleep(1);
}

// put down chopsticks
void put_fork(int phnum)
{

    sem_wait(&mutex);

    // state that thinking
    state[phnum] = THINKING;

    printf("Philosopher %d putting fork %d and %d down\n",
           phnum + 1, LEFT + 1, phnum + 1);
    printf("Philosopher %d is thinking\n", phnum + 1);

    test(LEFT);
    test(RIGHT);

    sem_post(&mutex);
}

void* philosopher(void* num)
{ int n=2;

    while (1) {

        int* i = num;

        sleep(1);

        take_fork(*i);

        sleep(0);

        put_fork(*i);
        n--;
    }
}

int main()
{

    int i;
    pthread_t thread_id[N];

    // initialize the semaphores
    sem_init(&mutex, 0, 1);

    for (i = 0; i < N; i++)

        sem_init(&S[i], 0, 0);

    for (i = 0; i < N; i++) {

        // create philosopher processes
        pthread_create(&thread_id[i], NULL,
                       philosopher, &phil[i]);

        printf("Philosopher %d is thinking\n", i + 1);
    }

    for (i = 0; i < N; i++)

        pthread_join(thread_id[i], NULL);
}



//Dining phelosopher using Monitor----------------------------------------------------------------------------------------------------------------------------------------------------


#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

#define NUM_PHILOSOPHERS 5
int cnt = 0;

typedef struct {
    pthread_mutex_t mutex;
    pthread_cond_t cond[NUM_PHILOSOPHERS];
    int state[NUM_PHILOSOPHERS]; // 0=THINKING, 1=HUNGRY, 2=EATING
} Monitor;

Monitor monitor;

enum { THINKING, HUNGRY, EATING };

void pickup_forks(int philosopher_id);
void return_forks(int philosopher_id);
void test(int philosopher_id);
void* philosopher(void* arg);

#define LEFT_FORK(phil_id) (phil_id)
#define RIGHT_FORK(phil_id) ((phil_id + 1) % NUM_PHILOSOPHERS)

void monitor_init() {
    pthread_mutex_init(&monitor.mutex, NULL);
    for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
        pthread_cond_init(&monitor.cond[i], NULL);
        monitor.state[i] = THINKING;
    }
}

void pickup_forks(int philosopher_id) {
    pthread_mutex_lock(&monitor.mutex);
    monitor.state[philosopher_id] = HUNGRY; // Explicitly set to HUNGRY
    test(philosopher_id);
    while (monitor.state[philosopher_id] != EATING) {
        pthread_cond_wait(&monitor.cond[philosopher_id], &monitor.mutex);
    }
    pthread_mutex_unlock(&monitor.mutex);
}

void return_forks(int philosopher_id) {
    pthread_mutex_lock(&monitor.mutex);
    monitor.state[philosopher_id] = THINKING;
    printf("Philosopher %d released forks %d and %d\n",
           philosopher_id, LEFT_FORK(philosopher_id), RIGHT_FORK(philosopher_id));
    test((philosopher_id + NUM_PHILOSOPHERS - 1) % NUM_PHILOSOPHERS);
    test((philosopher_id + 1) % NUM_PHILOSOPHERS);
    pthread_mutex_unlock(&monitor.mutex);
}

void test(int philosopher_id) {
    int left = (philosopher_id + NUM_PHILOSOPHERS - 1) % NUM_PHILOSOPHERS;
    int right = (philosopher_id + 1) % NUM_PHILOSOPHERS;

    if (monitor.state[philosopher_id] == HUNGRY &&
        (monitor.state[left] != EATING ||
        monitor.state[right] != EATING)) {
        monitor.state[philosopher_id] = EATING;
        if(monitor.state[left] == EATING){
        printf("Philosopher %d acquired forks %d and %d\n",
               philosopher_id, LEFT_FORK(philosopher_id), LEFT_FORK(philosopher_id));
        }
        else{
        printf("Philosopher %d acquired forks %d and %d\n",
               philosopher_id, LEFT_FORK(philosopher_id), RIGHT_FORK(philosopher_id));
        }
        pthread_cond_signal(&monitor.cond[philosopher_id]);
        cnt++;
    }
    if (cnt >= 6) exit(0); // Exit after 6 acquisitions for demo
}

void* philosopher(void* arg) {
    int philosopher_id = *(int*)arg;
    while (1) {
        printf("Philosopher %d is thinking\n", philosopher_id);
        sleep(1);

        // Explicit transition to HUNGRY state
        printf("Philosopher %d is hungry\n", philosopher_id);
        pickup_forks(philosopher_id);

        printf("Philosopher %d is eating\n", philosopher_id);
        sleep(1);

        return_forks(philosopher_id);
    }
}

int main() {
    pthread_t philosophers[NUM_PHILOSOPHERS];
    int philosopher_ids[NUM_PHILOSOPHERS];
    monitor_init();

    for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
        philosopher_ids[i] = i;
        pthread_create(&philosophers[i], NULL, philosopher, &philosopher_ids[i]);
    }

    for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
        pthread_join(philosophers[i], NULL);
    }

    return 0;
}


//Producer Consumer problem Usnig Semaphore ----------------------------------------------------------------------------------------------------------------------------------------------------


#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

#define BUFFER_SIZE 5  // Buffer size

int buffer[BUFFER_SIZE];  // Shared buffer
int in = 0, out = 0;      // Producer and consumer index

sem_t empty, full, sem;  // Semaphores

// Producer function
void *producer(void *arg) {
    int item;
    for (int i = 1; i <= 10; i++) {  // Producing 10 items
        item = i;

        sem_wait(&empty);  // Wait if buffer is full
        sem_wait(&sem);    // Lock access to buffer (acts like a mutex)

        buffer[in] = item;  // Add item to buffer
        printf("Producer produced: %d\n", item);
        in = (in + 1) % BUFFER_SIZE;  // Move to next buffer slot (circular)

        sem_post(&sem);  // Unlock buffer
        sem_post(&full); // Signal that buffer has new item

        sleep(1);  // Simulate production time
    }
    return NULL;
}

// Consumer function
void *consumer(void *arg) {
    int item;
    for (int i = 1; i <= 10; i++) {  // Consuming 10 items
        sem_wait(&full);  // Wait if buffer is empty
        sem_wait(&sem);   // Lock access to buffer (acts like a mutex)

        item = buffer[out];  // Remove item from buffer
        printf("Consumer consumed: %d\n", item);
        out = (out + 1) % BUFFER_SIZE;  // Move to next buffer slot (circular)

        sem_post(&sem);  // Unlock buffer
        sem_post(&empty); // Signal that buffer has space

        sleep(2);  // Simulate consumption time
    }
    return NULL;
}

int main() {
    pthread_t prod, cons;  // Thread variables

    // Initialize semaphores
    sem_init(&empty, 0, BUFFER_SIZE);  // Buffer starts empty
    sem_init(&full, 0, 0);  // No items in buffer initially
    sem_init(&sem, 0, 1);  // Acts like a mutex (initial value = 1)

    // Create producer and consumer threads
    pthread_create(&prod, NULL, producer, NULL);
    pthread_create(&cons, NULL, consumer, NULL);

    // Wait for threads to finish
    pthread_join(prod, NULL);
    pthread_join(cons, NULL);

    // Destroy semaphores
    sem_destroy(&empty);
    sem_destroy(&full);
    sem_destroy(&sem);

    return 0;
}





//Producer Consumer problem Usnig MUTEX ----------------------------------------------------------------------------------------------------------------------------------------------------


#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

#define BUFFER_SIZE 5  // Maximum buffer size

int buffer[BUFFER_SIZE];  // Shared buffer
int in = 0, out = 0;      // Producer & Consumer index
int count = 0;            // Number of items in buffer

pthread_mutex_t mutex;          // Mutex for locking buffer access
pthread_cond_t buffer_not_full; // Condition variable for producer
pthread_cond_t buffer_not_empty;// Condition variable for consumer

// Producer function
void *producer(void *arg) {
    int item;
    for (int i = 1; i <= 10; i++) {  // Producing 10 items
        item = i;

        pthread_mutex_lock(&mutex);  // Lock buffer access

        while (count == BUFFER_SIZE) // If buffer is full, wait
            pthread_cond_wait(&buffer_not_full, &mutex);

        buffer[in] = item;  // Add item to buffer
        printf("Producer produced: %d\n", item);
        in = (in + 1) % BUFFER_SIZE;  // Move to next buffer slot (circular)
        count++;  // Increase buffer count

        pthread_cond_signal(&buffer_not_empty);  // Signal consumer that buffer is not empty
        pthread_mutex_unlock(&mutex);  // Unlock buffer

        sleep(1);  // Simulate production time
    }
    return NULL;
}

// Consumer function
void *consumer(void *arg) {
    int item;
    for (int i = 1; i <= 10; i++) {  // Consuming 10 items
        pthread_mutex_lock(&mutex);  // Lock buffer access

        while (count == 0)  // If buffer is empty, wait
            pthread_cond_wait(&buffer_not_empty, &mutex);

        item = buffer[out];  // Remove item from buffer
        printf("Consumer consumed: %d\n", item);
        out = (out + 1) % BUFFER_SIZE;  // Move to next buffer slot (circular)
        count--;  // Decrease buffer count

        pthread_cond_signal(&buffer_not_full);  // Signal producer that buffer is not full
        pthread_mutex_unlock(&mutex);  // Unlock buffer

        sleep(2);  // Simulate consumption time
    }
    return NULL;
}

int main() {
    pthread_t prod, cons;  // Thread variables

    // Initialize mutex and condition variables
    pthread_mutex_init(&mutex, NULL);
    pthread_cond_init(&buffer_not_full, NULL);
    pthread_cond_init(&buffer_not_empty, NULL);

    // Create producer and consumer threads
    pthread_create(&prod, NULL, producer, NULL);
    pthread_create(&cons, NULL, consumer, NULL);

    // Wait for threads to finish
    pthread_join(prod, NULL);
    pthread_join(cons, NULL);

    // Destroy mutex and condition variables
    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&buffer_not_full);
    pthread_cond_destroy(&buffer_not_empty);

    return 0;
}




//// SRJF  ----------------------------------------------------------------------------------------------------------------------------------------------------




#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>

using namespace std;


struct Process {
    int id;
    int arrivalTime;
    int burstTime;
    int completionTime;
    int waitingTime;
    int turnAroundTime;
};


bool fcfs(int arivaln,int shortest)
{
    if(arivaln<shortest)
    {
        return 1;
    }
    else {
        return 0;
    }
}
int findShortestRemainingTimeProcess(vector<Process> &processes, vector<int> &remainingTime, int currentTime) {
    int minTime = INT_MAX;
    int shortestProcess = -1;
    for (size_t i = 0; i < processes.size(); i++) {
        if (processes[i].arrivalTime <= currentTime && remainingTime[i] > 0) {
            if (remainingTime[i] < minTime || (remainingTime[i] == minTime && fcfs(processes[i].arrivalTime,processes[shortestProcess].arrivalTime))) {
                minTime = remainingTime[i];
                shortestProcess = i;
            }
        }
    }
    return shortestProcess;
}


void calculateTimes(vector<Process> &processes) {
    for (auto &process : processes) {
        process.turnAroundTime = process.completionTime - process.arrivalTime;
        process.waitingTime = process.turnAroundTime - process.burstTime;
    }
}


void displayGanttChart(vector<int> &ganttChart, vector<int> &timeMarkers) {
    cout << "\nGantt Chart:\n";
    for (auto processId : ganttChart) {
        cout << "| P" << processId << " ";
    }
    cout << "|\n";
    for (auto time : timeMarkers) {
        cout << time << setw(5);
    }
    cout << "\n";
}


void displayDetailedGanttChart(vector<int> &detailedChart) {
    cout << "\nDetailed Gantt Chart (Unit by Unit):\n";
    for (int time = 0; time < detailedChart.size(); time++) {
        cout << "Time " << time<<"-"<<time+1 << ": P" << detailedChart[time] << "\n";
    }
}


void SRTFScheduling(vector<Process> &processes) {
    int n = processes.size();
    vector<int> remainingTime(n);
    for (int i = 0; i < n; i++) {
        remainingTime[i] = processes[i].burstTime;
    }

    int completed = 0, currentTime = 0;
    vector<int> ganttChart;
    vector<int> timeMarkers;
    vector<int> detailedChart;

    while (completed != n) {
        int shortestProcess = findShortestRemainingTimeProcess(processes, remainingTime, currentTime);

        if (shortestProcess == -1) {

            detailedChart.push_back(-1);
            currentTime++;
            continue;
        }


        if (ganttChart.empty() || ganttChart.back() != processes[shortestProcess].id) {
            ganttChart.push_back(processes[shortestProcess].id);
            timeMarkers.push_back(currentTime);
        }

        detailedChart.push_back(processes[shortestProcess].id);
        remainingTime[shortestProcess]--;
        currentTime++;


        if (remainingTime[shortestProcess] == 0) {
            processes[shortestProcess].completionTime = currentTime;
            completed++;
        }
    }
    timeMarkers.push_back(currentTime);
    calculateTimes(processes);
    displayGanttChart(ganttChart, timeMarkers);
    displayDetailedGanttChart(detailedChart);
}


void displayProcessTable(vector<Process> &processes) {
    cout << "\nProcess Table:\n";
       float avtt=0,avgwt=0,count=0;
    cout << left << setw(10) << "Process" << setw(15) << "Arrival Time" << setw(15) << "Burst Time" << setw(15);
    cout<< "Completion Time" << setw(15) << "Tarn ar- Time" << "wait Time" << endl;
    for (auto &process : processes) {

count++;
avtt=avtt+process.turnAroundTime;
avgwt=avgwt+process.waitingTime;
        cout << left << setw(10) << process.id << setw(15) << process.arrivalTime << setw(15) << process.burstTime;
        cout<< setw(15) << process.completionTime << setw(15) << process.turnAroundTime << process.waitingTime << endl;
    }
    cout<< "\t\t\t\t\t\t\t"<<avtt/count<<"\t\t"<<avgwt/count<<endl;
}

int main() {
    // Define processes with their arrival and burst times
    vector<Process> processes = {
        {1, 4, 5},
        {2, 6, 4},
        {3, 0, 3},
        {4, 6, 2},
        {5, 5, 4}
    };



    SRTFScheduling(processes);


    displayProcessTable(processes);

    return 0;
}


///priority scheduling ---------------------------------------------------------------------------------------------------------------------------------------------------------


// C++ implementation for Priority Scheduling with 
//Different Arrival Time priority scheduling
/*1. sort the processes according to arrival time 
2. if arrival time is same the acc to priority
3. apply fcfs
*/

#include <bits/stdc++.h>

using namespace std;

#define totalprocess 5

// Making a struct to hold the given input 

struct process
{
int at,bt,pr,pno;
};

process proc[50];

/*
Writing comparator function to sort according to priority if 
arrival time is same 
*/

bool comp(process a,process b)
{
if(a.at == b.at)
{
return a.pr<b.pr;
}
else
{
    return a.at<b.at;
}
}

// Using FCFS Algorithm to find Waiting time
void get_wt_time(int wt[])
{
// declaring service array that stores cumulative burst time 
int service[50];

// Initialising initial elements of the arrays
service[0] = proc[0].at;
wt[0]=0;


for(int i=1;i<totalprocess;i++)
{
service[i]=proc[i-1].bt+service[i-1];

wt[i]=service[i]-proc[i].at;

// If waiting time is negative, change it into zero
    
    if(wt[i]<0)
    {
    wt[i]=0;
    }
}

}

void get_tat_time(int tat[],int wt[])
{
// Filling turnaroundtime array

for(int i=0;i<totalprocess;i++)
{
    tat[i]=proc[i].bt+wt[i];
}
    
}

void findgc()
{
//Declare waiting time and turnaround time array
int wt[50],tat[50];

double wavg=0,tavg=0;

// Function call to find waiting time array
get_wt_time(wt);
//Function call to find turnaround time
get_tat_time(tat,wt);
    
int stime[50],ctime[50];

stime[0] = proc[0].at;
ctime[0]=stime[0]+tat[0];

// calculating starting and ending time
for(int i=1;i<totalprocess;i++)
    {
        stime[i]=ctime[i-1];
        ctime[i]=stime[i]+tat[i]-wt[i];
    }
    
cout<<"Process_no\tStart_time\tComplete_time\tTurn_Around_Time\tWaiting_Time"<<endl;
    
    // display the process details
    
for(int i=0;i<totalprocess;i++)
    {
        wavg += wt[i];
        tavg += tat[i];
        
        cout<<proc[i].pno<<"\t\t"<<
            stime[i]<<"\t\t"<<ctime[i]<<"\t\t"<<
            tat[i]<<"\t\t\t"<<wt[i]<<endl;
    }
    
        // display the average waiting time
        //and average turn around time
    
    cout<<"Average waiting time is : ";
    cout<<wavg/(float)totalprocess<<endl;
    cout<<"average turnaround time : ";
    cout<<tavg/(float)totalprocess<<endl;

}

int main()
{
int arrivaltime[] = { 1, 2, 3, 4, 5 };
int bursttime[] = { 3, 5, 1, 7, 4 };
int priority[] = { 3, 4, 1, 7, 8 };
    
for(int i=0;i<totalprocess;i++)
{
    proc[i].at=arrivaltime[i];
    proc[i].bt=bursttime[i];
    proc[i].pr=priority[i];
    proc[i].pno=i+1;
    } 
    
    //Using inbuilt sort function
    
    sort(proc,proc+totalprocess,comp);
    
    //Calling function findgc for finding Gantt Chart
    
    findgc(); 

    return 0;
}

///round_ROBIN ---------------------------------------------------------------------------------------------------------------------------------------------------------


//C++ Program for implementing
//Round Robin Algorithm
//code by sparsh_cbs
#include <iostream>

using namespace std;

void queueUpdation(int queue[],int timer,int arrival[],int n, int maxProccessIndex){
    int zeroIndex;
    for(int i = 0; i < n; i++){
        if(queue[i] == 0){
            zeroIndex = i;
            break;
        }
    }   
    queue[zeroIndex] = maxProccessIndex + 1;
}

void queueMaintainence(int queue[], int n){
    for(int i = 0; (i < n-1) && (queue[i+1] != 0) ; i++){
        int temp = queue[i];
        queue[i] = queue[i+1];
        queue[i+1] = temp; 
    }
}

void checkNewArrival(int timer, int arrival[], int n, int maxProccessIndex,int queue[]){
    if(timer <= arrival[n-1]){
       bool newArrival = false;
       for(int j = (maxProccessIndex+1); j < n; j++){
             if(arrival[j] <= timer){
              if(maxProccessIndex < j){
                 maxProccessIndex = j;
                 newArrival = true;
              }
           }
       }
       //adds the incoming process to the ready queue
       //(if any arrives)
       if(newArrival)
          queueUpdation(queue,timer,arrival,n, maxProccessIndex);
    }
}

//Driver Code
int main(){
    int n,tq, timer = 0, maxProccessIndex = 0;
    float avgWait = 0, avgTT = 0;
    cout << "\nEnter the time quanta : ";
    cin>>tq;
    cout << "\nEnter the number of processes : ";
    cin>>n;
    int arrival[n], burst[n], wait[n], turn[n], queue[n], temp_burst[n];
    bool complete[n];

    cout << "\nEnter the arrival time of the processes : ";
    for(int i = 0; i < n; i++)
        cin>>arrival[i];

    cout << "\nEnter the burst time of the processes : ";
    for(int i = 0; i < n; i++){
        cin>>burst[i];
        temp_burst[i] = burst[i];
    }

    for(int i = 0; i < n; i++){    //Initializing the queue and complete array
        complete[i] = false;
        queue[i] = 0;
    }
    while(timer < arrival[0])    //Incrementing Timer until the first process arrives
        timer++; 
    queue[0] = 1;
    
    while(true){
        bool flag = true;
        for(int i = 0; i < n; i++){
            if(temp_burst[i] != 0){
                flag = false;
                break;
            }
        }
        if(flag)
            break;

        for(int i = 0; (i < n) && (queue[i] != 0); i++){
            int ctr = 0;
            while((ctr < tq) && (temp_burst[queue[0]-1] > 0)){
                temp_burst[queue[0]-1] -= 1;
                timer += 1;
                ctr++;

                //Checking and Updating the ready queue until all the processes arrive
                checkNewArrival(timer, arrival, n, maxProccessIndex, queue);
            }
            //If a process is completed then store its exit time
            //and mark it as completed
            if((temp_burst[queue[0]-1] == 0) && (complete[queue[0]-1] == false)){
                //turn array currently stores the completion time
                turn[queue[0]-1] = timer;        
                complete[queue[0]-1] = true;
            }
            
              //checks whether or not CPU is idle
            bool idle = true;
            if(queue[n-1] == 0){
                for(int i = 0; i < n && queue[i] != 0; i++){
                    if(complete[queue[i]-1] == false){
                        idle = false;
                    }
                }
            }
            else
                idle = false;

            if(idle){
                timer++;
                checkNewArrival(timer, arrival, n, maxProccessIndex, queue);
            }
      
            //Maintaining the entries of processes 
            //after each premption in the ready Queue
            queueMaintainence(queue,n);
        }
    }

    for(int i = 0; i < n; i++){
        turn[i] = turn[i] - arrival[i];
        wait[i] = turn[i] - burst[i];
    }

    cout << "\nProgram No.\tArrival Time\tBurst Time\tWait Time\tTurnAround Time"
         << endl;
    for(int i = 0; i < n; i++){
        cout<<i+1<<"\t\t"<<arrival[i]<<"\t\t"
          <<burst[i]<<"\t\t"<<wait[i]<<"\t\t"<<turn[i]<<endl;
    }
    for(int i =0; i< n; i++){
        avgWait += wait[i];
        avgTT += turn[i]; 
    }
    cout<<"\nAverage wait time : "<<(avgWait/n)
      <<"\nAverage Turn Around Time : "<<(avgTT/n);

    return 0;
    
}

/// res Cond
#include <iostream>
#include <thread>
#include <chrono>

using namespace std;

const int BUFFER_SIZE = 5; // Fixed buffer size
int buffer[BUFFER_SIZE];    // Shared buffer
int in = 0;                 // Producer's index in the buffer
int out = 0;                // Consumer's index in the buffer

void producer() {
    for (int item = 0; item < 5; item++) { // Produce 10 items
        buffer[in] = item; // Write item to the buffer
        cout << "Produced: " << item << " at index " << in << endl;
        in = (in + 1) % BUFFER_SIZE; // Move to the next buffer index

        // Simulate delay to allow consumer to intervene
        this_thread::sleep_for(chrono::milliseconds(200));
    }
}

void consumer() {
    for (int i = 0; i < 5; i++) { // Consume 10 items
        // Simulate delay to allow producer to intervene


        int item = buffer[out]; // Read item from the buffer
        cout << "Consumed: " << item << " from index " << out << endl;
        out = (out + 1) % BUFFER_SIZE; // Move to the next buffer index
        this_thread::sleep_for(chrono::milliseconds(800));
    }
}

int main() {
    thread producer_thread(producer);
    thread consumer_thread(consumer);

    producer_thread.join();
    consumer_thread.join();

    return 0;
}
